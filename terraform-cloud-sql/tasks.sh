# Download necessary files
# Create a directory and fetch the required Terraform scripts from the Cloud Storage bucket with:

mkdir sql-with-terraform
cd sql-with-terraform
gsutil cp -r gs://spls/gsp234/gsp234.zip .

# Unzip the downloaded content.
unzip gsp234.zip

# Understand the code
# Take a look at the contents of the main.tf file:
cat main.tf

# Example Output:

...
resource "google_sql_database_instance" "master" {
  name                 = "example-mysql-${random_id.name.hex}"
  project              = var.project
  region               = var.region
  database_version     = var.database_version
  master_instance_name = var.master_instance_name
  settings {
    tier                        = var.tier
    activation_policy           = var.activation_policy
    authorized_gae_applications = var.authorized_gae_applications
    disk_autoresize             = var.disk_autoresize
    dynamic "backup_configuration" {
      for_each = [var.backup_configuration]
      content {
        binary_log_enabled = lookup(backup_configuration.value, "binary_log_enabled", null)
        enabled            = lookup(backup_configuration.value, "enabled", null)
        start_time         = lookup(backup_configuration.value, "start_time", null)
      }
    }
    dynamic "ip_configuration" {
      for_each = [var.ip_configuration]
      content {
        ipv4_enabled    = lookup(ip_configuration.value, "ipv4_enabled", true)
        private_network = lookup(ip_configuration.value, "private_network", null)
        require_ssl     = lookup(ip_configuration.value, "require_ssl", null)
        dynamic "authorized_networks" {
          for_each = lookup(ip_configuration.value, "authorized_networks", [])
          content {
            expiration_time = lookup(authorized_networks.value, "expiration_time", null)
            name            = lookup(authorized_networks.value, "name", null)
            value           = lookup(authorized_networks.value, "value", null)
          }
        }
      }
    }
...

# Run Terraform
# The terraform init command is used to initialize a working directory containing Terraform configuration files.
# This command performs several different initialization steps in order to prepare a working directory for use. This command is always safe to run multiple times, to bring the working directory up to date with changes in the configuration.
# Run terraform init:
terraform init

# The terraform plan command is an optional but recommended command and is used to create an execution plan. Terraform performs a refresh, unless explicitly disabled, and then determines what actions are necessary to achieve the desired state specified in the configuration files.
# This command is a convenient way to check whether the execution plan for a set of changes matches your expectations without making any changes to real resources or to the state. For example, terraform plan might be run before committing a change to version control, to create confidence that it will behave as expected.
# Run terraform plan:
terraform plan -out=tfplan

# The optional -out argument can be used to save the generated plan to a file for later execution with terraform apply.
# The terraform apply command is used to apply the changes required to reach the desired state of the configuration or the pre-determined set of actions generated by a terraform plan execution plan.
# Apply the Terraform plan you just created:
terraform apply tfplan

# This will take a little while to complete. Once complete you will see an output as below:
# Apply complete! Resources: 5 added, 0 changed, 0 destroyed.
# The state of your infrastructure has been saved to the path
# below. This state is required to modify and destroy your
# infrastructure, so keep it safe. To inspect the complete state
# use the `terraform show` command.
# State path: terraform.tfstate
# Outputs:
generated_user_password = <sensitive>
instance_address = 35.232.204.44
instance_address_time_to_retire =
instance_name = example-mysql-6808
self_link = https://www.googleapis.com/sql/v1beta4/projects/[PROJECT_ID]/instances/example-mysql-6808

# Create Cloud SQL instance using Terraform script.
# Cloud SQL Proxy
# What the proxy provides
# The Cloud SQL Proxy provides secure access to your Cloud SQL Second Generation instances without having to allowlist IP addresses or configure SSL.

# Accessing your Cloud SQL instance using the Cloud SQL Proxy offers these advantages:

# Secure connections: The proxy automatically encrypts traffic to and from the database using TLS 1.2 with a 128-bit AES cipher; SSL certificates are used to verify client and server identities.
# Easier connection management: The proxy handles authentication with Cloud SQL, removing the need to provide static IP addresses.
# Note: You do not need to use the proxy or configure SSL to connect to Cloud SQL from App Engine standard or the flexible environment. These connections use a "built-in" proxy implementation automatically.
# How the Cloud SQL Proxy works
# The Cloud SQL Proxy works by having a local client, called the proxy, running in the local environment. Your application communicates with the proxy with the standard protocol used by your database. The proxy uses a secure tunnel to communicate with its companion process running on the server.

# Installing the Cloud SQL Proxy
# Download the proxy:
wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O cloud_sql_proxy

# Make the proxy executable:
chmod +x cloud_sql_proxy

# You can install the proxy anywhere in your environment. The location of the proxy binaries does not impact where it listens for data from your application.
# Proxy startup options
# When you start the proxy, you provide it with the following sets of information:
# What Cloud SQL instances it should establish connections to
# Where it will listen for data coming from your application to be sent to Cloud SQL
# Where it will find the credentials it will use to authenticate your application to Cloud SQL
# The proxy startup options you provide determine whether it will listen on a TCP port or on a Unix socket. If it is listening on a Unix socket, it creates the socket at the location you choose; usually, the /cloudsql/ directory. For TCP, the proxy listens on localhost by default.

# Test connection to the database
# Start by running the Cloud SQL proxy for the Cloud SQL instance:

export GOOGLE_PROJECT=$(gcloud config get-value project)
MYSQL_DB_NAME=$(terraform output -json | jq -r '.instance_name.value')
MYSQL_CONN_NAME="${GOOGLE_PROJECT}:us-central1:${MYSQL_DB_NAME}"

# Run the following command:
./cloud_sql_proxy -instances=${MYSQL_CONN_NAME}=tcp:3306

# Now you'll start another Cloud Shell tab by clicking on plus (+) icon. You'll use this shell to connect to the Cloud SQL proxy.
# Navigate to sql-with-terraform directory:
cd ~/sql-with-terraform

# Get the generated password for MYSQL:
echo MYSQL_PASSWORD=$(terraform output -json | jq -r '.generated_user_password.value')

# Test the MySQL connection:
mysql -udefault -p --host 127.0.0.1 default

# When prompted, enter the value of MYSQL_PASSWORD, found in the output above, and press Enter.
# You should successfully log into the MYSQL command line. Exit from MYSQL by typing Ctrl + d.
# If you go back to the first Cloud Shell tab you'll see logs for the connections made to the Cloud SQL Proxy.